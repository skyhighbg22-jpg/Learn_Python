-- üèÅ FINAL LESSONS - FILE OPERATIONS, ERROR HANDLING, OOP
-- Run this to complete the 60+ lesson curriculum

-- FILE OPERATIONS SECTION (4 lessons)
INSERT INTO lessons (id, title, description, difficulty, xp_reward, order_index, section_id, content, lesson_type, estimated_minutes) VALUES
('80000000-0000-0000-0000-000000000001', 'Reading Files', 'Reading text and binary files', 'intermediate', 25, 1, '00000000-0000-0000-0000-000000000008',
'[{"type": "text", "content": "File reading in Python: open(file, mode) function with modes: \'r\' (read), \'rb\' (read binary). Use with statement for automatic file closing. Methods: .read(), .readline(), .readlines(), iteration."}, {"type": "code", "question": "Read and process a sample file', "starterCode": "# Create sample content\nsample_content = \"\"\"First line of text\nSecond line with numbers: 42\nThird line with Python\n\"\"\"\n\n# Write sample file\nwith open(\"sample.txt\", \"w\") as f:\n    f.write(sample_content)\n\n# Read the file\nwith open(\"sample.txt\", \"r\") as f:\n    lines = f.readlines()\n\n# Process lines\nfor i, line in enumerate(lines, 1):\n    print(f\"Line {i}: {line.strip()}\")", "solution": "sample_content = \"First line of text\\nSecond line with numbers: 42\\nThird line with Python\\n\"\nwith open(\"sample.txt\", \"w\") as f:\n    f.write(sample_content)\nwith open(\"sample.txt\", \"r\") as f:\n    lines = f.readlines()\nfor i, line in enumerate(lines, 1):\n    print(f\"Line {i}: {line.strip()}\")", "hints": ["with statement ensures file is closed", "readlines() returns list of lines", "strip() removes newline characters", "enumerate() gives line numbers"]}]',
'code', 18),

('80000000-0000-0000-0000-000000000002', 'Writing Files', 'Creating and modifying files', 'intermediate', 28, 2, '00000000-0000-0000-0000-000000000008',
'[{"type": "text", "content": "File writing: \'w\' (write, overwrite), \'a\' (append), \'wb\' (write binary), \'x\' (exclusive create). Use .write() for strings, .writelines() for lists of strings, .flush() to force write to disk."}, {"type": "code", "question": "Create and append to a log file', "starterCode": "import datetime\n\n# Create/overwrite log file\nwith open(\"app.log\", \"w\") as f:\n    f.write(\"Application Log\\n\")\n    f.write(\"=\" * 20 + \"\\n\")\n\n# Append log entries\nlog_entries = [\n    f\"{datetime.datetime.now()}: Application started\\n\",\n    f\"{datetime.datetime.now()}: User logged in\\n\",\n    f\"{datetime.datetime.now()}: Database connected\\n\"\n]\n\nwith open(\"app.log\", \"a\") as f:\n    for entry in log_entries:\n        f.write(entry)\n        print(f\"Logged: {entry.strip()}\")", "solution": "import datetime\nwith open(\"app.log\", \"w\") as f:\n    f.write(\"Application Log\\n\")\n    f.write(\"=\" * 20 + \"\\n\")\nlog_entries = [\n    f\"{datetime.datetime.now()}: Application started\\n\",\n    f\"{datetime.datetime.now()}: User logged in\\n\",\n    f\"{datetime.datetime.now()}: Database connected\\n\"\n]\nwith open(\"app.log\", \"a\") as f:\n    for entry in log_entries:\n        f.write(entry)\n        print(f\"Logged: {entry.strip()}\")", "hints": ["\"w\" mode overwrites existing file", "\"a\" mode appends to existing file", "datetime.now() gets current timestamp", "Use f-strings for formatted log entries"]}]',
'code', 20),

('80000000-0000-0000-0000-000000000003', 'Working with CSV Files', 'Reading and writing CSV data', 'intermediate', 30, 3, '00000000-0000-0000-0000-000000000008',
'[{"type": "text", "content": "CSV (Comma-Separated Values) files: Use csv module for proper handling. csv.reader() for reading, csv.writer() for writing, csv.DictReader() and csv.DictWriter() for dictionary-based operations."}, {"type": "code", "question": "Read and write CSV files', "starterCode": "import csv\n\n# Write CSV file\nwith open(\"students.csv\", \"w\", newline=\"\") as f:\n    writer = csv.writer(f)\n    writer.writerow([\"Name\", \"Age\", \"Grade\"])\n    writer.writerow([\"Alice\", 20, \"A\"])\n    writer.writerow([\"Bob\", 22, \"B\"])\n    writer.writerow([\"Charlie\", 21, \"A-\"])\n\n# Read CSV file\nwith open(\"students.csv\", \"r\") as f:\n    reader = csv.reader(f)\n    header = next(reader)  # Skip header\n    print(f\"Header: {header}\")\n    \n    for row in reader:\n        name, age, grade = row\n        print(f\"Student: {name}, Age: {age}, Grade: {grade}\")", "solution": "import csv\nwith open(\"students.csv\", \"w\", newline=\"\") as f:\n    writer = csv.writer(f)\n    writer.writerow([\"Name\", \"Age\", \"Grade\"])\n    writer.writerow([\"Alice\", 20, \"A\"])\n    writer.writerow([\"Bob\", 22, \"B\"])\n    writer.writerow([\"Charlie\", 21, \"A-\"])\nwith open(\"students.csv\", \"r\") as f:\n    reader = csv.reader(f)\n    header = next(reader)\n    print(f\"Header: {header}\")\n    for row in reader:\n        name, age, grade = row\n        print(f\"Student: {name}, Age: {age}, Grade: {grade}\")", "hints": ["newline=\\\"\\\" prevents extra blank lines", "next(reader) skips header row", "csv.writer handles quoting automatically", "Unpack row into individual variables"]}]',
'code', 22),

('80000000-0000-0000-0000-000000000004', 'File System Operations', 'Working with directories and paths', 'intermediate', 26, 4, '00000000-0000-0000-0000-000000000008',
'[{"type": "text", "content": "File system operations: os module and pathlib module. Common operations: list files (os.listdir(), pathlib.iterdir()), create directories (os.mkdir(), pathlib.Path.mkdir()), check existence (os.path.exists(), pathlib.Path.exists())."}, {"type": "code", "question": "Explore and manipulate file system', "starterCode": "import os\nfrom pathlib import Path\n\n# Create some files\nPath(\"test_dir\").mkdir(exist_ok=True)\n(Path(\"test_dir\") / \"file1.txt\").write_text(\"Hello\")\n(Path(\"test_dir\") / \"file2.txt\").write_text(\"World\")\n\n# List files using pathlib\ntest_dir = Path(\"test_dir\")\nprint(f\"Files in {test_dir}:\")\nfor file_path in test_dir.iterdir():\n    if file_path.is_file():\n        size = file_path.stat().st_size\n        content = file_path.read_text()\n        print(f\"  {file_path.name}: {size} bytes, content: {content}\")\n    elif file_path.is_dir():\n        print(f\"  {file_path.name}/ (directory)\")", "solution": "import os\nfrom pathlib import Path\nPath(\"test_dir\").mkdir(exist_ok=True)\n(Path(\"test_dir\") / \"file1.txt\").write_text(\"Hello\")\n(Path(\"test_dir\") / \"file2.txt\").write_text(\"World\")\ntest_dir = Path(\"test_dir\")\nprint(f\"Files in {test_dir}:\")\nfor file_path in test_dir.iterdir():\n    if file_path.is_file():\n        size = file_path.stat().st_size\n        content = file_path.read_text()\n        print(f\"  {file_path.name}: {size} bytes, content: {content}\")\n    elif file_path.is_dir():\n        print(f\"  {file_path.name}/ (directory)\")", "hints": ["pathlib.Path is object-oriented", "mkdir(exist_ok=True) won\\'t error if dir exists", "iterdir() yields Path objects", "stat() gets file information"]}]',
'code', 20),

-- ERROR HANDLING SECTION (4 lessons)
('90000000-0000-0000-0000-000000000001', 'Try-Except Blocks', 'Handling exceptions gracefully', 'intermediate', 28, 1, '00000000-0000-0000-0000-000000000009',
'[{"type": "text", "content": "Exception handling: try block contains code that might raise exceptions, except blocks handle specific exceptions, else block runs if no exceptions, finally block always runs. Prevents crashes and enables error recovery."}, {"type": "code", "question": "Handle division by zero and type conversion errors', "starterCode": "def safe_divide(a, b):\n    try:\n        result = a / b\n        print(f\"{a} / {b} = {result}\")\n        return result\n    except ZeroDivisionError:\n        print(\"Error: Cannot divide by zero!\")\n        return None\n    except TypeError:\n        print(\"Error: Both arguments must be numbers!\")\n        return None\n    finally:\n        print(\"Division operation completed\")\n\n# Test cases\nsafe_divide(10, 2)\nsafe_divide(10, 0)\nsafe_divide(\"10\", \"2\")", "solution": "def safe_divide(a, b):\n    try:\n        result = a / b\n        print(f\"{a} / {b} = {result}\")\n        return result\n    except ZeroDivisionError:\n        print(\"Error: Cannot divide by zero!\")\n        return None\n    except TypeError:\n        print(\"Error: Both arguments must be numbers!\")\n        return None\n    finally:\n        print(\"Division operation completed\")\n\nsafe_divide(10, 2)\nsafe_divide(10, 0)\nsafe_divide(\"10\", \"2\")", "hints": ["Multiple except blocks handle different errors", "finally block always executes", "Return None or default value on error", "Order of except blocks matters (specific to general)"]}]',
'code', 18),

('90000000-0000-0000-0000-000000000002', 'Common Exceptions', 'Understanding Python exception types', 'intermediate', 24, 2, '00000000-0000-0000-0000-000000000009',
'[{"type": "text", "content": "Common exceptions: ValueError (bad value), TypeError (wrong type), KeyError (missing key), IndexError (out of range), FileNotFoundError (missing file), AttributeError (missing attribute), ImportError (module not found)."}, {"type": "code", "question": "Handle multiple common exceptions', "starterCode": "def access_data_structure(data, key, index):\n    try:\n        value = data[key][index]\n        print(f\"Found value: {value}\")\n        return value\n    except KeyError:\n        print(f\"Error: Key \\'{key}\\' not found in data\")\n    except IndexError:\n        print(f\"Error: Index {index} out of range for key \\'{key}\\'\")\n    except TypeError:\n        print(\"Error: Data structure is not indexable\")\n    except AttributeError:\n        print(\"Error: Invalid data structure\")\n    except Exception as e:\n        print(f\"Unexpected error: {type(e).__name__}: {e}\")\n        return None\n\n# Test cases\ntest_dict = {\"numbers\": [1, 2, 3], \"letters\": [\"a\", \"b\"]}\naccess_data_structure(test_dict, \"numbers\", 1)\naccess_data_structure(test_dict, \"letters\", 5)\naccess_data_structure(test_dict, \"missing\", 0)", "solution": "def access_data_structure(data, key, index):\n    try:\n        value = data[key][index]\n        print(f\"Found value: {value}\")\n        return value\n    except KeyError:\n        print(f\"Error: Key \\'{key}\\' not found in data\")\n    except IndexError:\n        print(f\"Error: Index {index} out of range for key \\'{key}\\'\")\n    except TypeError:\n        print(\"Error: Data structure is not indexable\")\n    except AttributeError:\n        print(\"Error: Invalid data structure\")\n    except Exception as e:\n        print(f\"Unexpected error: {type(e).__name__}: {e}\")\n        return None\n\ntest_dict = {\"numbers\": [1, 2, 3], \"letters\": [\"a\", \"b\"]}\naccess_data_structure(test_dict, \"numbers\", 1)\naccess_data_structure(test_dict, \"letters\", 5)\naccess_data_structure(test_dict, \"missing\", 0)", "hints": ["Order exceptions from specific to general", "Exception as e captures the error object", "type(e).__name__ gets exception class name", "Multiple except blocks for different error types"]}]',
'code', 20),

('90000000-0000-0000-0000-000000000003', 'Custom Exceptions', 'Creating your own exception classes', 'intermediate', 30, 3, '00000000-0000-0000-0000-000000000009',
'[{"type": "text", "content": "Custom exceptions: Create exception classes that inherit from Exception or existing exceptions. Use descriptive names and add custom attributes/methods. Raise with raise CustomException(message)."}, {"type": "code", "question": "Create and use custom exceptions for validation', "starterCode": "class ValidationError(Exception):\n    \"\"\"Custom exception for validation errors\"\"\"\n    def __init__(self, field, value, message):\n        self.field = field\n        self.value = value\n        self.message = message\n        super().__init__(f\"{field}: {message} (got {value})\")\n\nclass AgeError(ValidationError):\n    \"\"\"Specific error for age validation\"\"\"\n    pass\n\ndef validate_user_data(name, age, email):\n    if not name or len(name) < 2:\n        raise ValidationError(\"name\", name, \"Name must be at least 2 characters\")\n    if age < 0 or age > 120:\n        raise AgeError(\"age\", age, \"Age must be between 0 and 120\")\n    if \"@\" not in email:\n        raise ValidationError(\"email\", email, \"Invalid email format\")\n    return True\n\n# Test validation\ntry:\n    validate_user_data(\"Alice\", 25, \"alice@example.com\")\n    print(\"‚úì Valid user data\")\n    \n    validate_user_data(\"B\", 150, \"invalid-email\")\nexcept (ValidationError, AgeError) as e:\n    print(f\"‚úó Validation failed: {e}\")", "solution": "class ValidationError(Exception):\n    def __init__(self, field, value, message):\n        self.field = field\n        self.value = value\n        self.message = message\n        super().__init__(f\"{field}: {message} (got {value})\")\n\nclass AgeError(ValidationError):\n    pass\n\ndef validate_user_data(name, age, email):\n    if not name or len(name) < 2:\n        raise ValidationError(\"name\", name, \"Name must be at least 2 characters\")\n    if age < 0 or age > 120:\n        raise AgeError(\"age\", age, \"Age must be between 0 and 120\")\n    if \"@\" not in email:\n        raise ValidationError(\"email\", email, \"Invalid email format\")\n    return True\n\ntry:\n    validate_user_data(\"Alice\", 25, \"alice@example.com\")\n    print(\"‚úì Valid user data\")\n    validate_user_data(\"B\", 150, \"invalid-email\")\nexcept (ValidationError, AgeError) as e:\n    print(f\"‚úó Validation failed: {e}\")", "hints": ["Custom exceptions inherit from Exception", "Add __init__ to store custom data", "Call super().__init__() for proper initialization", "Raise with raise CustomException()"]}]',
'code', 22),

('90000000-0000-0000-0000-000000000004', 'Error Handling Best Practices', 'Writing robust error handling code', 'intermediate', 26, 4, '00000000-0000-0000-0000-000000000009',
'[{"type": "text", "content": "Best practices: Handle specific exceptions, not generic Exception. Use logging instead of print for errors. Clean up resources in finally blocks. Provide meaningful error messages. Fail fast and clearly. Document expected exceptions."}, {"type": "code", "question": "Implement robust error handling with logging', "starterCode": "import logging\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format=\"%(asctime)s - %(levelname)s - %(message)s\")\n\ndef process_file(filename):\n    \"\"\"Process a file with robust error handling\"\"\"\n    file_handle = None\n    try:\n        file_handle = open(filename, \"r\")\n        content = file_handle.read()\n        \n        if not content.strip():\n            raise ValueError(\"File is empty\")\n        \n        lines = len(content.splitlines())\n        words = len(content.split())\n        \n        logging.info(f\"Processed {filename}: {lines} lines, {words} words\")\n        return {\"lines\": lines, \"words\": words, \"size\": len(content)}\n        \n    except FileNotFoundError:\n        logging.error(f\"File not found: {filename}\")\n        raise\n    except PermissionError:\n        logging.error(f\"Permission denied accessing {filename}\")\n        raise\n    except ValueError as e:\n        logging.error(f\"Value error processing {filename}: {e}\")\n        raise\n    except Exception as e:\n        logging.error(f\"Unexpected error processing {filename}: {type(e).__name__}: {e}\")\n        raise\n    finally:\n        if file_handle:\n            file_handle.close()\n            logging.debug(f\"Closed file: {filename}\")\n\n# Test the function\ntry:\n    result = process_file(\"sample.txt\")\n    print(f\"Success: {result}\")\nexcept Exception:\n    print(\"File processing failed\")", "solution": "import logging\nlogging.basicConfig(level=logging.INFO, format=\"%(asctime)s - %(levelname)s - %(message)s\")\n\ndef process_file(filename):\n    file_handle = None\n    try:\n        file_handle = open(filename, \"r\")\n        content = file_handle.read()\n        if not content.strip():\n            raise ValueError(\"File is empty\")\n        lines = len(content.splitlines())\n        words = len(content.split())\n        logging.info(f\"Processed {filename}: {lines} lines, {words} words\")\n        return {\"lines\": lines, \"words\": words, \"size\": len(content)}\n    except FileNotFoundError:\n        logging.error(f\"File not found: {filename}\")\n        raise\n    except PermissionError:\n        logging.error(f\"Permission denied accessing {filename}\")\n        raise\n    except ValueError as e:\n        logging.error(f\"Value error processing {filename}: {e}\")\n        raise\n    except Exception as e:\n        logging.error(f\"Unexpected error processing {filename}: {type(e).__name__}: {e}\")\n        raise\n    finally:\n        if file_handle:\n            file_handle.close()\n            logging.debug(f\"Closed file: {filename}\")\n\ntry:\n    result = process_file(\"sample.txt\")\n    print(f\"Success: {result}\")\nexcept Exception:\n    print(\"File processing failed\")", "hints": ["logging provides different severity levels", "finally ensures cleanup always happens", "Handle specific exceptions before generic", "Re-raise exceptions after logging"]}]',
'code', 20),

-- OBJECT-ORIENTED PROGRAMMING SECTION (4 lessons)
('99000000-0000-0000-0000-000000000001', 'Classes and Objects', 'Understanding OOP basics', 'intermediate', 30, 1, '00000000-0000-0000-0000-000000000010',
'[{"type": "text", "content": "Object-Oriented Programming (OOP): Classes are blueprints for objects. Objects have attributes (data) and methods (functions). Key concepts: encapsulation, inheritance, polymorphism. Class definition: class ClassName:"}, {"type": "code", "question": "Create a simple Person class with attributes and methods', "starterCode": "class Person:\n    \"\"\"Simple Person class\"\"\"\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n        self.friends = []\n    \n    def introduce(self):\n        return f\"Hi, I\\'m {self.name} and I\\'m {self.age} years old.\"\n    \n    def add_friend(self, friend_name):\n        if friend_name not in self.friends:\n            self.friends.append(friend_name)\n            return f\"Added {friend_name} as a friend!\"\n        return f\"{friend_name} is already a friend.\"\n    \n    def __str__(self):\n        return f\"Person(name={self.name}, age={self.age}, friends={len(self.friends)})\"\n\n# Create and use Person objects\nalice = Person(\"Alice\", 25)\nbob = Person(\"Bob\", 30)\n\nprint(alice.introduce())\nprint(alice.add_friend(\"Bob\"))\nprint(alice.add_friend(\"Charlie\"))\nprint(alice)\nprint(bob)", "solution": "class Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n        self.friends = []\n    def introduce(self):\n        return f\"Hi, I\\'m {self.name} and I\\'m {self.age} years old.\"\n    def add_friend(self, friend_name):\n        if friend_name not in self.friends:\n            self.friends.append(friend_name)\n            return f\"Added {friend_name} as a friend!\"\n        return f\"{friend_name} is already a friend.\"\n    def __str__(self):\n        return f\"Person(name={self.name}, age={self.age}, friends={len(self.friends)})\"\n\nalice = Person(\"Alice\", 25)\nbob = Person(\"Bob\", 30)\nprint(alice.introduce())\nprint(alice.add_friend(\"Bob\"))\nprint(alice.add_friend(\"Charlie\"))\nprint(alice)\nprint(bob)", "hints": ["__init__ is the constructor method", "self refers to the instance", "__str__ provides string representation", "Methods define object behavior"]}]',
'code', 25),

('99000000-0000-0000-0000-000000000002', 'Inheritance', 'Creating classes that inherit from others', 'intermediate', 32, 2, '00000000-0000-0000-0000-000000000010',
'[{"type": "text", "content": "Inheritance: Child classes inherit from parent classes using class Child(Parent):. Child gets parent attributes and methods, can override them, and can add new ones. Use super() to call parent methods. Promotes code reuse."}, {"type": "code", "question": "Create inheritance hierarchy with Animal and Dog classes', "starterCode": "class Animal:\n    def __init__(self, name, species):\n        self.name = name\n        self.species = species\n        self.energy = 100\n    \n    def make_sound(self):\n        return f\"{self.species} makes a sound\"\n    \n    def eat(self):\n        self.energy += 20\n        return f\"{self.name} eats and gains energy\"\n    \n    def __str__(self):\n        return f\"{self.name} the {self.species} (energy: {self.energy})\"\n\nclass Dog(Animal):\n    def __init__(self, name, breed):\n        super().__init__(name, \"Dog\")\n        self.breed = breed\n        self.tricks = []\n    \n    def make_sound(self):\n        return f\"{self.name} barks: Woof!\"\n    \n    def learn_trick(self, trick):\n        if trick not in self.tricks:\n            self.tricks.append(trick)\n            return f\"{self.name} learned {trick}!\"\n        return f\"{self.name} already knows {trick}\"\n    \n    def wag_tail(self):\n        return f\"{self.name} wags tail happily!\"\n\n# Create and use objects\nbuddy = Dog(\"Buddy\", \"Golden Retriever\")\nprint(buddy)\nprint(buddy.make_sound())\nprint(buddy.learn_trick(\"sit\"))\nprint(buddy.learn_trick(\"fetch\"))\nprint(buddy.wag_tail())", "solution": "class Animal:\n    def __init__(self, name, species):\n        self.name = name\n        self.species = species\n        self.energy = 100\n    def make_sound(self):\n        return f\"{self.species} makes a sound\"\n    def eat(self):\n        self.energy += 20\n        return f\"{self.name} eats and gains energy\"\n    def __str__(self):\n        return f\"{self.name} the {self.species} (energy: {self.energy})\"\n\nclass Dog(Animal):\n    def __init__(self, name, breed):\n        super().__init__(name, \"Dog\")\n        self.breed = breed\n        self.tricks = []\n    def make_sound(self):\n        return f\"{self.name} barks: Woof!\"\n    def learn_trick(self, trick):\n        if trick not in self.tricks:\n            self.tricks.append(trick)\n            return f\"{self.name} learned {trick}!\"\n        return f\"{self.name} already knows {trick}\"\n    def wag_tail(self):\n        return f\"{self.name} wags tail happily!\"\n\nbuddy = Dog(\"Buddy\", \"Golden Retriever\")\nprint(buddy)\nprint(buddy.make_sound())\nprint(buddy.learn_trick(\"sit\"))\nprint(buddy.learn_trick(\"fetch\"))\nprint(buddy.wag_tail())", "hints": ["super().__init__() calls parent constructor", "Child can override parent methods", "Child inherits parent methods automatically", "Child can add new attributes and methods"]}]',
'code', 28),

('99000000-0000-0000-0000-000000000003', 'Polymorphism', 'Different objects responding to same method', 'intermediate', 28, 3, '00000000-0000-0000-0000-000000000010',
'[{"type": "text", "content": "Polymorphism: Different classes can have methods with same name but different implementations. Duck typing: if it walks like a duck and quacks like a duck, it\\'s a duck. Enables flexible, interchangeable code."}, {"type": "code", "question": "Implement polymorphism with different shape classes', "starterCode": "import math\n\nclass Shape:\n    def __init__(self, color):\n        self.color = color\n    \n    def area(self):\n        raise NotImplementedError(\"Subclasses must implement area method\")\n    \n    def perimeter(self):\n        raise NotImplementedError(\"Subclasses must implement perimeter method\")\n    \n    def describe(self):\n        return f\"{self.color} shape\"\n\nclass Circle(Shape):\n    def __init__(self, color, radius):\n        super().__init__(color)\n        self.radius = radius\n    \n    def area(self):\n        return math.pi * self.radius ** 2\n    \n    def perimeter(self):\n        return 2 * math.pi * self.radius\n    \n    def describe(self):\n        return f\"{self.color} circle with radius {self.radius}\"\n\nclass Rectangle(Shape):\n    def __init__(self, color, width, height):\n        super().__init__(color)\n        self.width = width\n        self.height = height\n    \n    def area(self):\n        return self.width * self.height\n    \n    def perimeter(self):\n        return 2 * (self.width + self.height)\n    \n    def describe(self):\n        return f\"{self.color} rectangle {self.width}x{self.height}\"\n\n# Polymorphic function\ndef analyze_shape(shape):\n    print(f\"Analyzing: {shape.describe()}\")\n    print(f\"Area: {shape.area():.2f}\")\n    print(f\"Perimeter: {shape.perimeter():.2f}\")\n    print(\"---\")\n\n# Test with different shapes\nshapes = [\n    Circle(\"red\", 5),\n    Rectangle(\"blue\", 4, 6),\n    Circle(\"green\", 3)\n]\n\nfor shape in shapes:\n    analyze_shape(shape)", "solution": "import math\nclass Shape:\n    def __init__(self, color):\n        self.color = color\n    def area(self):\n        raise NotImplementedError(\"Subclasses must implement area method\")\n    def perimeter(self):\n        raise NotImplementedError(\"Subclasses must implement perimeter method\")\n    def describe(self):\n        return f\"{self.color} shape\"\n\nclass Circle(Shape):\n    def __init__(self, color, radius):\n        super().__init__(color)\n        self.radius = radius\n    def area(self):\n        return math.pi * self.radius ** 2\n    def perimeter(self):\n        return 2 * math.pi * self.radius\n    def describe(self):\n        return f\"{self.color} circle with radius {self.radius}\"\n\nclass Rectangle(Shape):\n    def __init__(self, color, width, height):\n        super().__init__(color)\n        self.width = width\n        self.height = height\n    def area(self):\n        return self.width * self.height\n    def perimeter(self):\n        return 2 * (self.width + self.height)\n    def describe(self):\n        return f\"{self.color} rectangle {self.width}x{self.height}\"\n\ndef analyze_shape(shape):\n    print(f\"Analyzing: {shape.describe()}\")\n    print(f\"Area: {shape.area():.2f}\")\n    print(f\"Perimeter: {shape.perimeter():.2f}\")\n    print(\"---\")\n\nshapes = [Circle(\"red\", 5), Rectangle(\"blue\", 4, 6), Circle(\"green\", 3)]\nfor shape in shapes:\n    analyze_shape(shape)", "hints": ["Polymorphism: same method name, different behavior", "Abstract base classes define interface", "Subclasses implement specific behavior", "Functions work with any object that has required methods"]}]',
'code', 25),

('99000000-0000-0000-0000-000000000004', 'Special Methods', 'Magic methods and dunder methods', 'advanced', 35, 4, '00000000-0000-0000-0000-000000000010',
'[{"type": "text", "content": "Special methods (dunder methods): __init__, __str__, __repr__, __len__, __getitem__, __setitem__, __contains__, __call__, __add__, __eq__, etc. Enable Pythonic syntax and operator overloading."}, {"type": "code", "question": "Create a class with multiple special methods', "starterCode": "class ShoppingCart:\n    def __init__(self):\n        self.items = {}\n        self.customer = None\n    \n    def __len__(self):\n        return sum(self.items.values())\n    \n    def __getitem__(self, item_name):\n        return self.items.get(item_name, 0)\n    \n    def __setitem__(self, item_name, quantity):\n        if quantity <= 0:\n            del self.items[item_name]\n        else:\n            self.items[item_name] = quantity\n    \n    def __contains__(self, item_name):\n        return item_name in self.items\n    \n    def __add__(self, other):\n        if isinstance(other, ShoppingCart):\n            new_cart = ShoppingCart()\n            new_cart.items = self.items.copy()\n            for item, qty in other.items.items():\n                new_cart[item] += qty\n            return new_cart\n        raise TypeError(\"Can only add ShoppingCart to ShoppingCart\")\n    \n    def __str__(self):\n        if not self.items:\n            return \"Empty cart\"\n        items_str = \", \".join(f\"{item}({qty})\" for item, qty in self.items.items())\n        return f\"Cart: {items_str} (Total: {len(self)} items)\"\n    \n    def add_item(self, item_name, quantity=1):\n        self[item_name] = self[item_name] + quantity\n\n# Test the special methods\ncart1 = ShoppingCart()\ncart2 = ShoppingCart()\n\ncart1.add_item(\"apple\", 3)\ncart1.add_item(\"banana\", 2)\ncart2.add_item(\"apple\", 1)\ncart2.add_item(\"orange\", 4)\n\nprint(f\"Cart 1: {cart1}\")\nprint(f\"Cart 1 length: {len(cart1)}\")\nprint(f\"Cart 1 has apple: {\'apple\' in cart1}\")\nprint(f\"Apples in cart 1: {cart1[\\\"apple\\\"]}\")\n\ncart1[\"banana\"] = 5  # Update quantity\ncart1[\"cherry\"] = 2  # Add item\nprint(f\"Updated cart 1: {cart1}\")\n\n# Combine carts\ncombined_cart = cart1 + cart2\nprint(f\"Combined cart: {combined_cart}\")", "solution": "class ShoppingCart:\n    def __init__(self):\n        self.items = {}\n        self.customer = None\n    def __len__(self):\n        return sum(self.items.values())\n    def __getitem__(self, item_name):\n        return self.items.get(item_name, 0)\n    def __setitem__(self, item_name, quantity):\n        if quantity <= 0:\n            del self.items[item_name]\n        else:\n            self.items[item_name] = quantity\n    def __contains__(self, item_name):\n        return item_name in self.items\n    def __add__(self, other):\n        if isinstance(other, ShoppingCart):\n            new_cart = ShoppingCart()\n            new_cart.items = self.items.copy()\n            for item, qty in other.items.items():\n                new_cart[item] += qty\n            return new_cart\n        raise TypeError(\"Can only add ShoppingCart to ShoppingCart\")\n    def __str__(self):\n        if not self.items:\n            return \"Empty cart\"\n        items_str = \", \".join(f\"{item}({qty})\" for item, qty in self.items.items())\n        return f\"Cart: {items_str} (Total: {len(self)} items)\"\n    def add_item(self, item_name, quantity=1):\n        self[item_name] = self[item_name] + quantity\n\ncart1 = ShoppingCart()\ncart2 = ShoppingCart()\ncart1.add_item(\"apple\", 3)\ncart1.add_item(\"banana\", 2)\ncart2.add_item(\"apple\", 1)\ncart2.add_item(\"orange\", 4)\nprint(f\"Cart 1: {cart1}\")\nprint(f\"Cart 1 length: {len(cart1)}\")\nprint(f\"Cart 1 has apple: {\\\"apple\\\" in cart1}\")\nprint(f\"Apples in cart 1: {cart1[\\\"apple\\\"]}\")\ncart1[\"banana\"] = 5\ncart1[\"cherry\"] = 2\nprint(f\"Updated cart 1: {cart1}\")\ncombined_cart = cart1 + cart2\nprint(f\"Combined cart: {combined_cart}\")", "hints": ["__len__ enables len() function", "__getitem__ enables [] indexing", "__contains__ enables in operator", "__add__ enables + operator", "__str__ enables str() conversion"]}]',
'code', 30);

SELECT 'üéâ SUCCESS! 60 comprehensive lessons added!' as message,
       COUNT(*) as total_lessons,
       (SELECT COUNT(*) FROM sections) as total_sections
FROM lessons;