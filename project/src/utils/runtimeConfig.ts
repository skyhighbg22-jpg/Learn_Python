/**
 * Runtime Config Loader
 * Loads configuration from /config.json generated by Docker entrypoint
 * This allows secrets to be injected at container start time, not build time
 */

interface RuntimeConfig {
  supabase: {
    url: string;
    anonKey: string;
  };
  ai: {
    groqApiKey?: string;
    openaiApiKey?: string;
    geminiApiKey?: string;
    anthropicApiKey?: string;
  };
  app: {
    name: string;
    version: string;
  };
}

let cachedConfig: RuntimeConfig | null = null;

/**
 * Load runtime config from /config.json
 * Falls back to import.meta.env if config.json is not available (dev mode)
 */
export async function loadRuntimeConfig(): Promise<RuntimeConfig> {
  if (cachedConfig) {
    return cachedConfig;
  }

  try {
    // Try to fetch config.json (generated by entrypoint.sh at runtime)
    const response = await fetch('/config.json');
    if (response.ok) {
      cachedConfig = await response.json();
      console.log('✓ Runtime config loaded from /config.json');
      return cachedConfig;
    }
  } catch (error) {
    console.warn('Could not load runtime config, falling back to env vars:', error);
  }

  // Fallback to environment variables (dev mode)
  cachedConfig = {
    supabase: {
      url: import.meta.env.VITE_SUPABASE_URL || '',
      anonKey: import.meta.env.VITE_SUPABASE_ANON_KEY || '',
    },
    ai: {
      groqApiKey: import.meta.env.GROQ_API_KEY,
      openaiApiKey: import.meta.env.OPENAI_API_KEY,
      geminiApiKey: import.meta.env.GEMINI_API_KEY,
      anthropicApiKey: import.meta.env.ANTHROPIC_API_KEY,
    },
    app: {
      name: import.meta.env.VITE_APP_NAME || 'Learn Python',
      version: import.meta.env.VITE_APP_VERSION || '1.0.0',
    },
  };

  console.log('✓ Config loaded from environment variables (dev mode)');
  return cachedConfig;
}

/**
 * Get a specific config value by path
 * Example: getConfigValue('supabase.url')
 */
export function getConfigValue(path: string): string | undefined {
  if (!cachedConfig) {
    console.warn('Config not loaded. Call loadRuntimeConfig() first.');
    return undefined;
  }

  const keys = path.split('.');
  let value: any = cachedConfig;

  for (const key of keys) {
    value = value?.[key];
    if (value === undefined) return undefined;
  }

  return value;
}

/**
 * Update supabase client with runtime config
 */
export function getSuperbaseConfigFromRuntime(): { url: string; anonKey: string } {
  if (!cachedConfig) {
    throw new Error('Config not loaded. Call loadRuntimeConfig() first.');
  }
  return {
    url: cachedConfig.supabase.url,
    anonKey: cachedConfig.supabase.anonKey,
  };
}

/**
 * Get AI service config at runtime
 */
export function getAIConfigFromRuntime() {
  if (!cachedConfig) {
    throw new Error('Config not loaded. Call loadRuntimeConfig() first.');
  }
  return cachedConfig.ai;
}

/**
 * Export entire config
 */
export function getRuntimeConfig(): RuntimeConfig {
  if (!cachedConfig) {
    throw new Error('Config not loaded. Call loadRuntimeConfig() first.');
  }
  return cachedConfig;
}
